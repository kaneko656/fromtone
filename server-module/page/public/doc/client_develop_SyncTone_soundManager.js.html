<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: client/develop/SyncTone/soundManager.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: client/develop/SyncTone/soundManager.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @overview このファイルが音関係の処理を行うモジュールとなる．WebAudioAPIを使用．
 * @author {@link https://github.com/kaneko656 Shoma Kaneko}
 * @version 1.0.0
 * @module soundManager
 * @see {@link module:soundManager/SyncAudio}
 * @see {@link module:soundManager/TimeValue}
 */

const TimeValue = require('./TimeValue.js')
const SyncAudio = require('./SyncAudio.js')
let syncAudios = {}
let soundList = {}
let soundNameList = []

let speakerPosition = {
    default: {
        x: 0,
        y: 0,
        z: 0
    }
}
let mySpeakerID = 'default'
let listenerPosition = {
    x: 0,
    y: 0,
    z: 0
}
// 1.0 が何mに相当するか
let areaScale = 1

let finishInit = false

// WebAudioAPI
let webAudio = null
let buffer = {}

try {
    window.AudioContext = window.AudioContext || window.webkitAudioContext
    webAudio = new AudioContext()
} catch (e) {
    webAudio = null
    console.log('Web Audio API is not supported in this browser')
}

let canUseModules = () => {
    if (webAudio) {
        return true
    }
    return false
}


/**
 * audioデータをロードする．このモジュールで利用できるように準備する．
 * @param {object} audioUrlList { keyName: url }
 */
// this.buffer[keyName] = decodedBuffer

exports.setAudioList = (audioUrlList) => {
    if (!canUseModules) {
        return
    }

    // url -> audio buffer
    let requestSound = (url, callback = () => {}) => {
        let request = new XMLHttpRequest()
        request.open('GET', url, true)
        request.responseType = 'arraybuffer'
        request.onload = function() {
            callback(request.response)
        }
        request.send()
    }

    // urlList -> (each) key, audio buffer
    let requestAllSound = (audioUrlList, callback = () => {}) => {
        let bufferList = {}
        let cnt = 0
        let length = Object.keys(audioUrlList).length
        for (let key in audioUrlList) {
            requestSound(audioUrlList[key], (buffer) => {
                callback(key, buffer)
                cnt++
                if (cnt == length) {
                    // loadFinish
                }
            })
        }
    }

    // aduio buffer -> decodedBuffer
    let decodeAudioData = (buffer, callback = () => {}) => {
        webAudio.decodeAudioData(buffer, function(decodedBuffer) {
            callback(decodedBuffer)
        }, (err) => {
            console.log(err)
        })
    }

    // AllProcess
    requestAllSound(audioUrlList, (key, buf) => {
        decodeAudioData(buf, (decodedBuffer) => {
            console.log('load: ' + key)
            buffer[key] = decodedBuffer
        })
    })

}

/**
 * 共有されている全スピーカの位置をセットする
 * @param {string} id このスピーカのID
 * @param {speakerPosition} speakerPosition { speakerID: { x, y, z } }
 */
exports.setSpeakerPosition = (id, _speakerPosition) => {
    speakerPosition = _speakerPosition
    if (id) {
        mySpeakerID = id
    }
}

/**
 * 共有されている全スピーカの位置をセットする
 * @param {string} id このスピーカのID
 * @param {speakerPosition} speakerPosition { speakerID: { x, y, z } }
 */
exports.updateSpeakerPosition = (id, position) => {
    speakerPosition[id] = position
}

/**
 * 再生
 * @param  {string} audioName    keyName of setAudioList
 * @param  {Object} [audioOptions={}] options of SyncAudio > name, destination, loop(boolean), startDateTime(UTCmillis), offset(sec), duration(sec)
 * @param  {Object} [syncOptions={}]
 * @return {AudioSyncController} functions  applyDBAP, applyDoppler, update
 */

exports.play = (audioName, audioOptions = {}, syncOptions = {}) => {
    if (!canUseModules) {
        return
    }
    if (!buffer[audioName]) {
        console.log(audioName + 'がありません SoundManager.js - play()')
        return
    }

    let gainNode = webAudio.createGain()
    gainNode.connect(webAudio.destination)
    gainNode.gain.value = 1.0
    audioOptions.destination = gainNode

    let soundManager = this
    let useDBAP = false
    let useDoppler = false
    let syncAudio = SyncAudio(webAudio, buffer[audioName], audioOptions)
    let timeValue = TimeValue()
    timeValue.updateEvent = (pre, next) => {
        let atNextTime = webAudio.currentTime + (next.time - Date.now()) / 1000
        if (useDBAP) {
            let nextDBAP = DBAP(next.value)
            let power = nextDBAP[mySpeakerID]
            gainNode.gain.linearRampToValueAtTime(power, atNextTime)
            console.log('DBAP', 'power:', power.toFixed(3), 'time:', atNextTime.toFixed(3))
        }
        if (useDoppler) {
            let rate = Doppler(pre.time, pre.value, next.time, next.value)
            if (rate) {
                syncAudio.source.playbackRate.linearRampToValueAtTime(rate, atNextTime)
                console.log('Doppler', 'rate:', rate.toFixed(3), 'time:', atNextTime.toFixed(3))
            }
        }
    }

    /**
     * AudioSyncController
     * @class
     */
    let AudioSyncController = {

        /**
         * AudioSyncController
         * @param  {boolean} apply DBAPを適応(defalut=false)
         */
        applyDBAP: (apply) => {
            useDBAP = apply
        },

        /**
         * AudioSyncController
         * @param  {boolean} apply Dopplerを適応(defalut=false)
         */
        applyDoppler: (apply) => {
            useDoppler = apply
        },

        /**
         * AudioSyncController
         * @param  {Object} updateValue { time: {x, y} }
         */
        update: (updateValue) => {
            timeValue.update(updateValue)
        }
    }
    return AudioSyncController
}


/**
 * DBAP法
 * @param {object} soundPosition {x, y}
 * @param {number} [rolloff=6.02 * 10]
 * @return {object} { speakerID: powerBalance(0.0-1.0) }
 */

let DBAP = exports.DBAP = (soundPosition, rolloff = 6.02 * 10) => {
    // console.log(speakerPosition, soundGx, soundGy)
    if (!speakerPosition) {
        return null
    }
    // スピーカの半径　無限大発散を防ぐ
    let speakerRadius = 0.00001
    let powerSum = 0
    let power = {}
    for (let name in speakerPosition) {
        let spX = speakerPosition[name].x
        let spY = speakerPosition[name].y
        let aX = soundPosition.x
        let aY = soundPosition.y
        let dist = Math.sqrt((aX - spX) * (aX - spX) + (aY - spY) * (aY - spY) + speakerRadius * speakerRadius)
        let rDist = Math.pow(dist, -rolloff / 20 * Math.log10(2))
        let p = rDist * rDist
        // エネルギーなので２乗
        power[name] = p
        powerSum += p
    }
    let result = {}
    if (powerSum != 0) {
        for (let name in power) {
            result[name] = power[name] / powerSum
        }
        // console.log('power', power / powerSum, ' = ', power, ' / ', powerSum)
        // console.log('power', power, ' = ', power, ' / ', powerSum)
    }
    return result
}

let Doppler = exports.Doppler = (preTime, prePosition, nextTime, nextPosition) => {

    let diffDist = culculateDist(listenerPosition, nextPosition) - culculateDist(listenerPosition, prePosition)
    let diffTime = nextTime - preTime
    if (diffTime == 0) {
        return
    }
    // m / ms
    let vs = areaScale * diffDist / diffTime
    // km/h
    vs = vs * 3600

    let rate = 340 / (340 - vs)
    return rate
}

let culculateDist = (a, b) => {
    return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y))
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-server_register.html">server/register</a></li><li><a href="module-soundManager.html">soundManager</a></li><li><a href="module-soundManager_SyncAudio.html">soundManager/SyncAudio</a></li><li><a href="module-soundManager_TimeValue.html">soundManager/TimeValue</a></li><li><a href="module-webSocket_ntpClient.html">webSocket/ntpClient</a></li><li><a href="module-webSocket_property.html">webSocket/property</a></li><li><a href="module-webSocket_register.html">webSocket/register</a></li><li><a href="module-webSocket_socketClient.html">webSocket/socketClient</a></li><li><a href="module-webSocket_spec.html">webSocket/spec</a></li><li><a href="module-webSocket_sync.html">webSocket/sync</a></li></ul><h3>Classes</h3><ul><li><a href="module-soundManager.play-AudioSyncController.html">AudioSyncController</a></li><li><a href="module-soundManager_SyncAudio-SyncAudio.html">SyncAudio</a></li><li><a href="module-soundManager_TimeValue-TimeValue.html">TimeValue</a></li></ul><h3>Events</h3><ul><li><a href="module-soundManager_SyncAudio-SyncAudio.html#event:finished">finished</a></li><li><a href="module-soundManager_TimeValue-TimeValue.html#event:updateEvent">updateEvent</a></li></ul><h3>Global</h3><ul><li><a href="global.html#onClick">onClick</a></li><li><a href="global.html#onWindowResize">onWindowResize</a></li><li><a href="global.html#start">start</a></li><li><a href="global.html#startTime">startTime</a></li><li><a href="global.html#Stats">Stats</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Tue Sep 19 2017 01:14:01 GMT+0900 (JST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
